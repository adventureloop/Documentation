\section{Generation Techniques}

\subsection{Simulated Generation}
Simulating the formation of the universe and planets is a very active area of 
research. Simulating the formation of the world is a technique that is rarely
used, but can created very realistic worlds.\\

The techniques used by dwarf fortress for simulating world terrain are a good
example of common methods. DFs first pass is to create contents by using fractal
division, this allows large scale island and world features that have a self 
simial shape. DF then does a number of passes to simulate errosion, weather 
patterns, prevailing wind flow and other world simulation methods.\\

Theres are a number of problems with
simulation the entire generation of a world that put it beyond our abilities. 
The first issue is one of time, simulations can be very resource intensive and 
can take a very long time to finish, our goal of creating the world on the fly 
puts this outside our reach. The next issue is that of scale, simulations needs
limits for each generation, or the simulation will just run for ever. With other
techniques we can create infinite world, this is much more desirable. These two
problems are enough to rule out creating generated worlds using simulation.\\

\subsection{Random Generation}
Taking values from a random or pseudo random number generate is a common 
technique to provide a random element within a system. Random Values can lead to
systems with a high level of entropy and there are a number of algorithms and 
techniques that take advantage of this method to create terrain simulations. Such
techniques are the main mechanic in the game Nethack, used to generate winding
dungeons that are different very time.\\

\subsubsection*{Mid Point Displacement}
The midpoint displacement algorithm works around raising relative levels around a
point, an offset grid is the best medium for this to work in. This leads to noisy
variation, it can be good for providing variation in a flat or rolling landscape.\\

MDP IMAGE\\

MDP works around picking a random point within the offset grid and increasing its
height slightly compared to those around. This can be done in a large number of 
interactions and the height variance can be altered with each, the final product 
being very noisy. Every cycle of this algorithms has a large cost and it is very
difficult to simulate edge conditions for unloaded chunks. MPD can be effect, but
expensive to run in increasing generations.\\

MDP RESULT IMAGE\\

\subsubsection*{Fault Algorithm}
The fault algorithm can implement either comparative raising or both raising and
lowering or height levels. Terrain generated with fault algorithms can be 
inherently smoother than MDP, yet takes a large number of generations to produce
interesting terrain.\\

FAULT IMAGE\\

The Fault algorithm works on a 2D grid, a line( or fault) is then drawn across the
grid, heights on either side of this line are raised and lowered respectively.
Smoothing can be added to improve the quality of the faulting, a sigmoid 
function produces quite a realistic value. The Fault algorithm shares the same
draw backs as the MDP algorithm.\\

FAULT RESULT IMAGE\\

\subsection{Noise Based Generation}
Noise functions produce random values in the real range [-1,1] based of some 
predefined function, purely random noise is very noisy and produces no noticeable
pattern. The noise we are going to explore for generation is called Coherent
Noise, that is instead of just random values changing across the pattern there 
is a smooth scaling between transitions within the noise.\\

\subsubsection*{Perlin Noise}
The type of noise we are going to use for generation is called Perlin Noise. 
Perlin Noise was developed for use in the movie Tron by Ken Perlin, he wanted to
break up the un realistically clean lines and shapes that the graphics system was
producing. Perlin Noise is very frequently used for generation in games and is 
even built into some programming languages.\\

Perlin Noise can be generated in by number of dimensions, but we will look at the
2D case to describe an approximation of how we derive the value for a given 
(x,y).\\

If we define our noise function noise(x,y)=z, where x,y,z are all real values
numbers. If we define our noise function of a 2D grid, where any fractional value
lies between points on the grid. If we consider the points around our (x,y), in
the 2D plane we have 4 of them, (x0,y0),(x0,y1),(x1,y0),(x1,y1).\\

GRID POINTS IMAGE;\\
GRADIENT POINTS IMAGE\\
TO GRADIENT IMAGE\\

The function g(xgrid,ygrid) = (gx,gy) will map a pseudo random gradient g to each
of our grid points. Also for each grid point we need to generate a vector to 
(x,y).\\

The influence of each gradient can be calculated by performing the dot product of
the gradient and the vector going from its grid point.

We finally take a weight average of the influences of the grid points, and ease
this over an awesomeness function\\

WEIGHT FUNCTION IMAGE\\

This will produce our final values.\\

\subsubsection*{Using Perlin Noise}
The process of generating noise can be quite involved and the process described
above has a number of additional optimisations placed upon it before we can use
it to generate terrain. The final Perlin Noise functions we will use come from
Ken Perlins noise library and have the following function prototype.\\

\begin{lstlisting}
double PerlinNoise2D(double x,double y,double alpha,double beta,int n);
\end{lstlisting}

For the above dimensions it can be seen that the noise function takes in the 
position for the desired value, in the number of dimensions. N is usually given
in the 6 to 10 range. The alpha value effects how noisy the final values are,with
1 being the noisiest and increasing values producing smoother functions.\\

\subsection{Conclusion}
The desired properties of the final generation system are the best criteria to
evaluate the possible approached. We aim to create a system that can generate
the terrain under the users position on the fly, this generation needs to be
reproducible despite the order in which the user interacts with the world. Most
of all the approach used needs to be a fast as possible to avoid locking up of
the system.\\

\begin{description}
\item[Simulation]
Simulated worlds can create highly realistic
and expansive terrain, but it suffers on speed, taking a long time to create a 
world. This speed factor rules out the possibility for use in an on the fly 
generated world such as we are aiming to create. 

\item[Random Generation] Random Generation, has 
interesting qualities, but is slow to create interesting worlds and it best
suited to fixed sizes. It is possible to use an overall general map, but 
difficult to reproduce out of ordered generations which we are likely to
experience. 

\item[Perlin Noise] Noise based generation is fast, at least compared to the other
methods, and is entirely reproducible from any state. These two qualities make it
perfect for our requirements. Noise can also be used on multiple dimensions, 
allowing height maps to be generated as well as 3D density maps leading to very
interesting realistic worlds.
\end{description}

Considering our requirements noised based generation is the best overall 
approach,
but as more complex worlds are create inspiration will come from other 
techniques.\\
